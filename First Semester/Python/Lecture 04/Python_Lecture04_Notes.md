# Функции и декораторы

Функции функций:
    Преиспользование кода
    Понятность кода
    Использование одних и тех же имен для переменных (области видимости)

Если в функции нет return, то просто вернется None

Есть (и у меня уже установлен) статический анализатор mypy, который типа помогает компилить, поэтому важны typehint'ы, то есть сигнатуры методов.

typehint'ы это круто, это класс и по ней теории очень много.

docstring'и - это тоже круто. PEP257 - про то, как нужно писать их.

typehint'ы никак не контролируют аргументы, то есть ошибки из-за них появиться не могут.

Опциональный аргумент - тот, который имеет значение по дефолту.

*args - любое количество позиционных аргументов. В методе это будет typle.

**kwargs - словарь, который забирает все "названные" при подаче в метод аргументы, для которых нет "названных" аргументов в сигнатуре метода. 

"Названные" переменные - с keyword'ом.

Если *args поставить в начале сигнатуры метода, то чтобы при использовании метода задать другие аргументы необходимо, чтобы они были "названные". Но всё-таки стоит args и kwargs писать в конце сигнатуры.

Если при вызове функции стоит аргумент со звездочкой, то это unpacking.
А если две звуздочки, то это unpacking для словаря.

Перегрузок нет в Python. Сигнатуры просто перетираются...

Внутри метода просто число не изменится, а list, например, изменится. Чтобы не изменять нужно использовать copy()

Если написать 

```
def foo(*, x, y):
    pass
```
то это говорит нам, что все метод должен обязательно вызываться только с keyword'ами.

А вот это наоборот:

```
def foo(x, y, /):
    pass
```
говорит нам о том, что keyword'ы использовать нельзя.

Дефолтные значения запоминаются... То есть 

```
def foo(l: list = []):
    l.append(1)
    print(l)
    
foo()
foo()
foo()
```
выдаст [1], потом [1, 1], потом [1,1,1]. Брэд, крч. Так лучше, конечно, не делать.

Сами функции можно юзать как переменные.

Декораторы какие-то странные, но можно типа 
